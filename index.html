<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0,maximun-scale=1.0,user-scalable=0">
    <meta name="format-detection" content="telephone=no">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<style media="screen">
canvas{
    display: block;
    margin: 0 auto;
    position: absolute;
    left: 50%;
    top: 50%;
    margin-top: -75px;
    margin-left: -75px;
}
</style>
<body>
    <canvas id="progress" width="150" height="150"></canvas>

    <script>
    const canvas = document.getElementById('progress');
    let circleLoading;

    class Progress{
        constructor([ctx, percent, circleX, circleY, radius, lineWidth, processNum]){
            this.ctx = ctx;
            this.percent = percent;
            this.circleX = circleX;
            this.circleY = circleY;
            this.radius = radius;
            this.lineWidth = lineWidth;
            this.process = processNum;
        }

        circle(cx, cy, r){
            this.ctx.beginPath();//新建一条路径
            this.ctx.moveTo(cx+r, cy);//制定圆环起始坐标
            this.ctx.lineWidth = this.lineWidth;//圆环线条的宽度
            this.ctx.strokeStyle = '#fff';//绘制轮廓的颜色
            this.ctx.arc(cx, cy, r, Math.PI*1.5, Math.PI * 2);
            this.ctx.closePath();//闭合路径
            this.ctx.stroke();//然后使用线条绘制圆环轮廓
        }
        sector(cx = this.cx, cy = this.cy, r = this.r, startAngle, endAngle, anti){
            this.ctx.beginPath();
            this.ctx.moveTo(cx, cy+r);
            this.ctx.lineWidth = this.lineWidth;
            this.ctx.strokeStyle = '#66BAB7';
            this.ctx.lineCap = 'round';

            this.ctx.arc(
                cx,
                cy,
                r,
                startAngle*(Math.PI/180.0)+(Math.PI/2),
                endAngle*(Math.PI/180.0)+(Math.PI/2),
                anti
            );
            this.ctx.stroke();
        }
        loading(percent = this.percent, endX = 0,endY){
            this.ctx.clearRect(0,0, this.circleX * 2, this.circleY * 2);//擦除之前的绘制效果，不然会产生叠加
            this.circle(this.circleX, this.circleY, this.radius);
            let endAngleY = endY || this.process/100*360;
            this.sector(this.circleX, this.circleY, this.radius, endX , endAngleY);
        }
    }


    let bar = new Progress([
        canvas.getContext('2d'),
        60,
        canvas.width/2,
        canvas.height/2,
        50,
        10,
        1
    ]);
    bar.loading();

    const start = (event) => {
        console.log(event);
        //判断几根手指
        if(event.touches.length == 1){
            event.preventDefault();
        }
        var touch = event.targetTouches[0];
        console.log(canvas.offsetLeft, canvas.offsetTop);
        console.log(touch.clientX, touch.clientY);
        canvas.addEventListener('touchmove', (event) => {
            var touch = event.targetTouches[0];
            bar.loading(undefined, undefined, touch.clientX, touch.clientY);
        });
    }

    const end = (event) => {
        canvas.removeEventListener('touchstart', start);
        canvas.removeEventListener('touchend', end);
    }

    canvas.addEventListener('touchstart',start);
    canvas.addEventListener('touchend', end);
    </script>
</body>
</html>
